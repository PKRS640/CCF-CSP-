# P3156 【深基15.例1】询问学号

## 题目描述

有 $n(n \le 2 \times 10^6)$ 名同学陆陆续续进入教室。我们知道每名同学的学号（在 $1$ 到 $10^9$ 之间），按进教室的顺序给出。上课了，老师想知道第 $i$ 个进入教室的同学的学号是什么（最先进入教室的同学 $i=1$），询问次数不超过 $10^5$ 次。

## 输入格式

第一行 $2$ 个整数 $n$ 和 $m$，表示学生个数和询问次数。

第二行 $n$ 个整数，表示按顺序进入教室的学号。

第三行 $m$ 个整数，表示询问第几个进入教室的同学。

## 输出格式

输出 $m$ 个整数表示答案，用换行隔开。

## 输入输出样例 #1

### 输入 #1

```
10 3
1 9 2 60 8 17 11 4 5 14
1 5 9
```

### 输出 #1

```
1
8
5
```





### 解题（引用自洛谷用户“[AveMarina](https://www.luogu.com.cn/user/277849)”）

```c++
#include "iostream"
#include "vector"
using namespace std;
vector<long> vec;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n,m,q;
    int ID;
    cin>>n>>m;
    while (n--){
        long x;
        cin>>x;
        vec.push_back(x);
    }

    while (m--){
        int idx;
        cin>>idx;
        cout<<vec[idx - 1]<<endl;
    }
}
```

PS：

## 1.`cin` 和 `cout` 在 C++ 中是**绑定**的。

代码：
`ios::sync_with_stdio(false)`;//关闭 C++ 和 C 的标准库输入输出流的同步，提升输入输出效率。
cin.tie(0) ;//解除 `cin` 和 `cout` 的绑定，这样输入和输出可以独立操作，进一步提高效率。

### 绑定的含义

默认情况下，`cin`（标准输入流）和 `cout`（标准输出流）是绑定在一起的。这意味着，当你进行输入操作时，`cin` 会确保在执行输入操作后，输出缓冲区中的内容会立刻刷新到屏幕上。例如：

```
cppCopy code#include <iostream>
using namespace std;

int main() {
    cout << "Please enter a number: ";
    int num;
    cin >> num;
    cout << "You entered: " << num << endl;
    return 0;
}
```

在这个例子中，当程序执行到 `cout << "Please enter a number: ";` 后，屏幕上会立刻显示提示信息。然后，当执行 `cin >> num;` 时，程序会等待用户输入，并且输入完成后，`cout` 会马上输出 `You entered: 你的输入`。这是因为 `cin` 和 `cout` 是绑定的，在输入操作后，输出流会自动刷新。

### 为什么会有绑定？

绑定的目的是为了确保输入和输出操作按照预期的顺序进行。即如果你在 `cin` 操作之前有 `cout` 输出，程序会先输出提示信息，接着再进行输入操作。这种同步机制在大多数情况下是有用的，但有时会导致效率问题。

### 解除绑定

C++ 提供了 `cin.tie()` 函数，可以解除 `cin` 和 `cout` 之间的绑定。解除绑定后，`cin` 不再依赖于 `cout` 的刷新机制。这样可以提升输入操作的效率，尤其是在需要大量输入时。

```
cppCopy codeios::sync_with_stdio(false);
cin.tie(0);
```

- `ios::sync_with_stdio(false)`：关闭 C++ 和 C 的标准输入输出流的同步，进一步提高效率。
- `cin.tie(0)`：解除 `cin` 和 `cout` 之间的绑定。这样，`cin` 不会因为 `cout` 刷新而等待，从而提高输入的速度。

### 示例：解除绑定前后的区别

**默认绑定的情况（有 `cin` 和 `cout` 绑定）**：

```
cppCopy code#include <iostream>
using namespace std;

int main() {
    int x;
    cout << "Enter a number: ";
    cin >> x; // 程序会等待输入并且刷新输出缓冲区
    cout << "You entered: " << x << endl;
    return 0;
}
```

**解除绑定后的情况**：

```
cppCopy code#include <iostream>
using namespace std;

int main() {
    ios::sync_with_stdio(false); // 禁用与 C 的同步
    cin.tie(0); // 解除 cin 和 cout 的绑定
    
    int x;
    cout << "Enter a number: "; // 这个输出不会立即刷新
    cin >> x; // 程序等待输入，不会马上刷新输出
    cout << "You entered: " << x << endl;
    return 0;
}
```

### 总结：

- 默认情况下，`cin` 和 `cout` 是绑定的，即 `cin` 操作后，`cout` 会自动刷新输出缓冲区。
- 通过 `cin.tie(0)` 可以解除 `cin` 和 `cout` 之间的绑定，提升程序的输入效率，特别是在处理大量数据时。

## 2.不要把数组开在主函数里，首先主函数的栈空间小，其次是CCF的机子是开几个数组算几个，而各大OJ是用多少数组算几个，注意考场别爆0；

**主函数栈空间小**：

- 在 C++ 中，函数的局部变量（比如数组）通常是分配在栈上，而栈空间是有限的。主函数和其它函数的栈空间是有限的，通常会受到操作系统和编译器的限制。
- 如果在主函数中开辟一个非常大的数组，可能会超出栈空间的限制，导致栈溢出错误，进而导致程序崩溃或无法运行。

**“CCF 的机子是开几个数组算几个”**：

- CCF（中国计算机大赛）是一个编程比赛，类似的 OJ 系统（如 LeetCode、牛客网等）也有机器资源的限制。这句话意思是，在线评测系统可能会对栈空间有限制。如果你的代码中使用了多个大数组，那么可能会导致超出评测机的栈空间限制，从而引发错误。

**“各大 OJ 是用多少数组算几个”**：

- 不同的 OJ 系统对每个程序允许的栈空间大小是不同的。比如某些 OJ 可能会限制每个用户的栈空间为 1MB、2MB 或更大。
- 如果你在代码中创建了多个大数组，这些数组会一起占用栈空间，可能会超过系统的栈空间限制，导致程序失败。

**“注意考场别爆0”**：

- 这是对考试场景的提醒。在编程竞赛或考试中，**"爆0"** 是指栈溢出或内存溢出（Stack Overflow）的问题。爆0 是因为程序尝试分配超过栈空间的内存，导致程序崩溃。因此，应该特别注意栈空间的使用，避免创建过大的数组或过多的局部变量。

### 为什么在主函数里开大数组不推荐？

- **栈空间有限**：主函数的栈空间较小，通常只有几百 KB 或 1MB。如果你在主函数中开一个大的数组（例如几百万个元素的数组），就可能会超出栈空间限制，导致程序崩溃。
- **大数组应开在堆上**：如果需要处理大数组，通常建议将数组放在 **堆** 上，而不是栈上。堆的内存限制要大得多，不容易超出。你可以通过 `new` 或 `malloc` 动态分配内存，或者使用 `std::vector` 来避免栈溢出。

### 推荐做法：

1. **使用动态内存分配**：当数组很大时，可以使用 `new` 或 `malloc` 动态分配内存，或者使用 `std::vector`，这会将内存分配到堆上而不是栈上。

   示例：

   ```cpp
   int *arr = new int[n];  // 动态分配内存到堆上
   ```

2. **使用 `std::vector`**：

   ```cpp
   #include <vector>
   std::vector<int> vec(n);  // 使用 vector 自动管理内存
   ```

3. **避免过大数组在栈上**：如果数组较大，尽量避免在主函数或递归函数中声明。可以将其声明为全局变量，或者使用堆内存分配。

### 总结：

这句话提醒你，在竞赛或考试环境中，要避免在栈上开辟过大的数组。因为栈空间有限，过大的数组可能会导致栈溢出，影响程序的正确执行。建议将较大的数据结构（如数组）分配到堆内存中，避免栈溢出问题。